/**
 * ğŸ¯ ä½¿ç”¨ä¸‰å¤§å®˜æ–¹ç»„ä»¶çš„ React Hook
 * 
 * é›†æˆï¼š
 * 1. UMA å®˜æ–¹é¢„è¨€æœº
 * 2. Polymarket å®˜æ–¹ CTF Exchange
 * 3. Gnosis Conditional Tokens
 */

import { useState, useEffect } from 'react';
import { ethers } from 'ethers';
import { UMAOracleClient, createYesNoQuery, parseYesNoResult } from '@/lib/uma/oracle-client';

// ä¸‰å¤§å®˜æ–¹ç»„ä»¶åœ°å€
const CONTRACTS = {
  // 1. UMA å®˜æ–¹é¢„è¨€æœº
  umaOracle: '0x263351499f82C107e540B01F0Ca959843e22464a',
  
  // 2. Polymarket å®˜æ–¹ CTF Exchange
  ctfExchange: '0xdFE02Eb6733538f8Ea35D585af8DE5958AD99E40',
  
  // 3. Gnosis Conditional Tokens
  conditionalTokens: '0xb171BBc6b1476ee1b6aD4Ac2cA7ed4AfFdFa10a2',
  
  // æ‚¨çš„é€‚é…å™¨ï¼ˆè¿æ¥ä¸‰è€…ï¼‰
  adapter: '0xaBf0e29946C63fa1920E00bEA95dDADeF70FD80C',
  
  // æµ‹è¯•ç”¨
  mockUSDC: '0x8d2dae90Dbc51dF7E18C1b857544AC979F87a77a',
  
  rpcUrl: 'https://polygon-amoy-bor-rpc.publicnode.com'
};

const ADAPTER_ABI = [
  "function initialize(bytes32 questionId, string title, string description, uint256 outcomeSlotCount, address rewardToken, uint256 reward, uint256 customLiveness) returns (bytes32)",
  "function getMarketCount() view returns (uint256)",
  "function getMarket(bytes32 questionId) view returns (tuple(bytes32 questionId, bytes32 conditionId, string title, string description, uint256 outcomeSlotCount, uint256 requestTimestamp, bool resolved, address rewardToken, uint256 reward, uint256[] payouts))",
  "function requestOraclePrice(bytes32 questionId) external returns (uint256)",
  "function resolve(bytes32 questionId) external"
];

const EXCHANGE_ABI = [
  "function fillOrder(tuple(uint256 salt, address maker, address signer, address taker, uint256 tokenId, uint256 makerAmount, uint256 takerAmount, uint256 expiration, uint256 nonce, uint256 feeRateBps, uint8 side, uint8 signatureType) order, bytes signature, uint256 fillAmount) external"
];

export interface Market {
  questionId: string;
  conditionId: string;
  title: string;
  description: string;
  outcomeSlotCount: number;
  resolved: boolean;
  payouts: number[];
}

/**
 * Hook: ä½¿ç”¨ Polymarket å®˜æ–¹ç³»ç»Ÿ
 */
export function usePolymarketSystem() {
  const [provider, setProvider] = useState<ethers.providers.JsonRpcProvider | null>(null);
  const [adapter, setAdapter] = useState<ethers.Contract | null>(null);
  const [exchange, setExchange] = useState<ethers.Contract | null>(null);
  const [umaClient, setUmaClient] = useState<UMAOracleClient | null>(null);
  
  useEffect(() => {
    // åˆå§‹åŒ–è¿æ¥
    const rpcProvider = new ethers.providers.JsonRpcProvider(CONTRACTS.rpcUrl);
    setProvider(rpcProvider);
    
    // åˆå§‹åŒ–é€‚é…å™¨
    const adapterContract = new ethers.Contract(
      CONTRACTS.adapter,
      ADAPTER_ABI,
      rpcProvider
    );
    setAdapter(adapterContract);
    
    // åˆå§‹åŒ– CTF Exchangeï¼ˆPolymarket å®˜æ–¹ï¼‰
    const exchangeContract = new ethers.Contract(
      CONTRACTS.ctfExchange,
      EXCHANGE_ABI,
      rpcProvider
    );
    setExchange(exchangeContract);
    
    // åˆå§‹åŒ– UMA å®¢æˆ·ç«¯
    const client = new UMAOracleClient(rpcProvider, CONTRACTS.umaOracle);
    setUmaClient(client);
  }, []);
  
  /**
   * ç»„ä»¶ 1: åˆ›å»ºå¸‚åœºï¼ˆä½¿ç”¨ Conditional Tokensï¼‰
   */
  const createMarket = async (
    title: string,
    description: string,
    rewardAmount: number,
    signer: ethers.Signer
  ) => {
    if (!adapter) throw new Error('Adapter not initialized');
    
    const questionId = ethers.utils.id(title + Date.now());
    const adapterWithSigner = adapter.connect(signer);
    
    const tx = await adapterWithSigner.initialize(
      questionId,
      title,
      description,
      2,  // YES/NO
      CONTRACTS.mockUSDC,
      ethers.utils.parseUnits(rewardAmount.toString(), 6),
      0   // é»˜è®¤æŒ‘æˆ˜æœŸ
    );
    
    await tx.wait();
    
    return questionId;
  };
  
  /**
   * ç»„ä»¶ 2: äº¤æ˜“ï¼ˆä½¿ç”¨ Polymarket å®˜æ–¹ CTF Exchangeï¼‰
   */
  const placeOrder = async (
    order: any,
    signature: string,
    signer: ethers.Signer
  ) => {
    if (!exchange) throw new Error('Exchange not initialized');
    
    const exchangeWithSigner = exchange.connect(signer);
    
    const tx = await exchangeWithSigner.fillOrder(
      order,
      signature,
      order.makerAmount
    );
    
    await tx.wait();
    
    return tx.hash;
  };
  
  /**
   * ç»„ä»¶ 3: ç»“ç®—ï¼ˆä½¿ç”¨ UMA å®˜æ–¹é¢„è¨€æœºï¼‰
   */
  const requestOracleResolution = async (
    questionId: string,
    signer: ethers.Signer
  ) => {
    if (!adapter) throw new Error('Adapter not initialized');
    
    const adapterWithSigner = adapter.connect(signer);
    
    // è¯·æ±‚ UMA é¢„è¨€æœº
    const tx = await adapterWithSigner.requestOraclePrice(questionId);
    await tx.wait();
    
    return tx.hash;
  };
  
  /**
   * è·å–å¸‚åœºåˆ—è¡¨
   */
  const getMarkets = async (): Promise<Market[]> => {
    if (!adapter) return [];
    
    try {
      const count = await adapter.getMarketCount();
      const markets: Market[] = [];
      
      for (let i = 0; i < count.toNumber(); i++) {
        // è¿™é‡Œéœ€è¦è·å– questionId åˆ—è¡¨
        // ç®€åŒ–ç¤ºä¾‹
      }
      
      return markets;
    } catch (error) {
      console.error('è·å–å¸‚åœºå¤±è´¥:', error);
      return [];
    }
  };
  
  /**
   * ç›‘å¬ UMA é¢„è¨€æœºäº‹ä»¶
   */
  const listenToOracleEvents = (
    onProposal: (data: any) => void,
    onDispute: (data: any) => void,
    onSettlement: (data: any) => void
  ) => {
    if (!umaClient) return;
    
    umaClient.onPriceProposed((requester, proposer, price) => {
      onProposal({ requester, proposer, price: price.toString() });
    });
    
    umaClient.onPriceDisputed((requester, disputer) => {
      onDispute({ requester, disputer });
    });
    
    umaClient.onPriceSettled((requester, price) => {
      const result = parseYesNoResult(price);
      onSettlement({ requester, price: price.toString(), result });
    });
  };
  
  return {
    // ä¸‰å¤§ç»„ä»¶
    umaOracle: CONTRACTS.umaOracle,
    ctfExchange: CONTRACTS.ctfExchange,
    conditionalTokens: CONTRACTS.conditionalTokens,
    
    // å®¢æˆ·ç«¯
    provider,
    adapter,
    exchange,
    umaClient,
    
    // åŠŸèƒ½å‡½æ•°
    createMarket,          // ç»„ä»¶3: Conditional Tokens
    placeOrder,            // ç»„ä»¶2: CTF Exchange
    requestOracleResolution, // ç»„ä»¶1: UMA Oracle
    getMarkets,
    listenToOracleEvents
  };
}

/**
 * ä½¿ç”¨ç¤ºä¾‹
 */
export function ExampleUsage() {
  const {
    createMarket,
    placeOrder,
    requestOracleResolution,
    listenToOracleEvents
  } = usePolymarketSystem();
  
  // åˆ›å»ºå¸‚åœº
  const handleCreateMarket = async () => {
    const questionId = await createMarket(
      "Test Market",
      "Will this work?",
      100,  // 100 USDC
      signer
    );
    console.log('å¸‚åœºå·²åˆ›å»º:', questionId);
  };
  
  // ç›‘å¬é¢„è¨€æœºäº‹ä»¶
  useEffect(() => {
    listenToOracleEvents(
      (data) => console.log('æ–°ææ¡ˆ:', data),
      (data) => console.log('æœ‰äº‰è®®:', data),
      (data) => console.log('å·²ç»“ç®—:', data)
    );
  }, []);
  
  return (
    <div>
      <button onClick={handleCreateMarket}>åˆ›å»ºå¸‚åœº</button>
    </div>
  );
}





