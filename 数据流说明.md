# 📊 数据流详细说明

## 🎯 你的问题

> 当我在前端后台创建市场，市场数据会到哪？  
> 数据库吗？然后链下读取数据库吗？

**答案**：是的！完全正确！✅

---

## 📋 完整数据流图

```
┌─────────────────────────────────────────────────────────┐
│          第 1 阶段：创建市场（数据库）                     │
└─────────────────────────────────────────────────────────┘

管理后台页面
app/admin/create-market/page.tsx
         │
         │ 填写表单：
         │ - 标题: "特斯拉 Q1 预测"
         │ - 描述: "..."
         │ - 分类: automotive
         │
         ↓ HTTP POST
         
API 路由
app/api/admin/markets/create/route.ts
         │
         │ const result = await db.query(
         │   `INSERT INTO markets (title, description, ...)
         │    VALUES ($1, $2, ...)`
         │ );
         │
         ↓ SQL INSERT
         
PostgreSQL / Supabase 数据库
markets 表
         │
         │ 保存数据:
         │ {
         │   id: 1,
         │   title: "特斯拉 Q1 预测",
         │   status: 'draft',            ← 草稿状态
         │   blockchain_status: 'not_created',  ← 未上链
         │   condition_id: null,         ← 还没有链上 ID
         │   views: 0,
         │   interested_users: 0
         │ }
         │
         ✅ 完成！成本 $0，耗时 < 100ms
```

---

```
┌─────────────────────────────────────────────────────────┐
│          第 2 阶段：前端显示市场（链下读取）               │
└─────────────────────────────────────────────────────────┘

用户访问前端页面
app/markets/page.tsx
         │
         │ useEffect(() => {
         │   loadMarkets();
         │ });
         │
         ↓ HTTP GET
         
API 路由（读取数据）
app/api/markets/route.ts 或
app/api/markets/[marketId]/route.ts
         │
         │ const { data } = await supabase
         │   .from('markets')
         │   .select('*')
         │   .eq('blockchain_status', 'not_created');
         │
         ↓ SQL SELECT
         
PostgreSQL / Supabase 数据库
markets 表
         │
         │ 返回数据:
         │ [{
         │   id: 1,
         │   title: "特斯拉 Q1 预测",
         │   blockchain_status: 'not_created',
         │   ...
         │ }]
         │
         ↓ JSON 响应
         
前端页面显示
components/MarketCard.tsx
         │
         │ 显示:
         │ ┌──────────────────────┐
         │ │ 特斯拉 Q1 预测        │
         │ │ 市场尚未激活          │
         │ │ [我感兴趣] [激活交易] │
         │ └──────────────────────┘
         │
         ✅ 完全链下读取！不调用区块链
```

---

```
┌─────────────────────────────────────────────────────────┐
│          第 3 阶段：激活市场（上链）                       │
└─────────────────────────────────────────────────────────┘

用户点击"激活并交易"或
感兴趣人数达到 5 人（定时任务）
         │
         ↓ HTTP POST
         
API 路由
app/api/admin/markets/[marketId]/activate/route.ts
         │
         │ activateMarketOnChain(marketId)
         │
         ↓
         
链上激活逻辑
lib/market-activation/blockchain-activator.ts
         │
         │ // 1. 从数据库读取市场信息
         │ const market = await db.query(
         │   `SELECT * FROM markets WHERE id = $1`
         │ );
         │
         │ // 2. 使用平台钱包调用智能合约
         │ const tx = await adapter.initialize(
         │   questionId,
         │   market.title,
         │   market.description,
         │   2, // YES/NO
         │   USDC_ADDRESS,
         │   rewardAmount,
         │   0
         │ );
         │
         ↓ 区块链交易
         
Polygon Amoy 区块链
TestUmaCTFAdapter 合约
         │
         │ 链上创建市场:
         │ - 生成 conditionId
         │ - 调用 ConditionalTokens
         │ - 调用 Oracle
         │ - 发出事件
         │
         ↓ 交易确认（30 秒）
         
更新数据库
         │
         │ await db.query(
         │   `UPDATE markets 
         │    SET blockchain_status = 'created',
         │        condition_id = $1,
         │        activated_at = NOW()
         │    WHERE id = $2`
         │ );
         │
         ↓
         
数据库现在有完整数据:
{
  id: 1,
  title: "特斯拉 Q1 预测",
  status: 'active',            ← 已激活
  blockchain_status: 'created', ← 已上链
  condition_id: '0xea6d...',   ← 链上 ID
  ...
}
         │
         ✅ 激活完成！现在可以交易
```

---

```
┌─────────────────────────────────────────────────────────┐
│          第 4 阶段：用户交易（混合模式）                   │
└─────────────────────────────────────────────────────────┘

前端读取市场
         │
         │ // 从数据库读取基本信息（快）
         │ const market = await fetch(
         │   `/api/markets/${marketId}`
         │ );
         │
         ↓ 数据库
         
返回市场信息（包含 condition_id）
         │
         │ {
         │   id: 1,
         │   condition_id: '0xea6d...',
         │   blockchain_status: 'created'
         │ }
         │
         ↓
         
用户提交订单（链下）
         │
         │ // EIP-712 签名
         │ const signature = await signOrder(order, signer);
         │
         │ // 提交到数据库（不上链）
         │ await fetch('/api/orders/create', {
         │   body: JSON.stringify({ ...order, signature })
         │ });
         │
         ↓ 保存到数据库
         
orders 表（PostgreSQL）
         │
         │ 链下匹配:
         │ - 查找相反方向订单
         │ - 价格匹配
         │ - 生成成交记录
         │
         ↓ 批量结算（每 5 分钟）
         
区块链结算
         │
         │ // 定时任务调用
         │ await ctfExchange.fillOrders(
         │   orders, signatures, amounts
         │ );
         │
         ✅ 最终在链上结算
```

---

## 🎯 关键点理解

### ✅ 数据在哪里？

| 阶段 | 数据位置 | 说明 |
|------|---------|------|
| **创建市场** | 数据库 | 100% 链下 |
| **显示市场** | 数据库 | 100% 链下（快速） |
| **激活前** | 数据库 | 链下 |
| **激活后** | 数据库 + 区块链 | 混合（数据库有元数据，区块链有 conditionId） |
| **订单匹配** | 数据库 | 链下（快速） |
| **订单结算** | 区块链 | 批量上链 |

### ✅ 读取数据从哪里？

```typescript
// ✅ 正确理解：

// 1. 前端显示市场列表（链下读取）
const markets = await fetch('/api/markets'); 
// → 从数据库读取 ✅
// → 不调用区块链 ✅
// → 速度快 < 100ms ✅

// 2. 显示市场详情（链下读取）
const market = await fetch(`/api/markets/${id}`);
// → 从数据库读取 ✅
// → 包含所有信息 ✅

// 3. 只有在需要交易时才读区块链
if (market.blockchain_status === 'created') {
  // 现在从区块链读取 Token 余额等
  const balance = await ctf.balanceOf(address, tokenId);
  // → 这步才调用区块链 ✅
}
```

---

## 📊 数据库表结构

```sql
CREATE TABLE markets (
  id SERIAL PRIMARY KEY,
  
  -- 基本信息（一直在数据库）
  title TEXT NOT NULL,
  description TEXT,
  main_category TEXT,
  image_url TEXT,
  
  -- 状态（一直在数据库）
  status TEXT DEFAULT 'draft',
  blockchain_status TEXT DEFAULT 'not_created',
  
  -- 链上信息（激活后填充）
  question_id TEXT,        ← 生成时就有，但还未上链
  condition_id TEXT,       ← 激活后才有
  adapter_address TEXT,    ← 激活后才有
  activated_at TIMESTAMP,  ← 激活时间
  
  -- 活跃度指标（一直在数据库）
  views INTEGER DEFAULT 0,
  interested_users INTEGER DEFAULT 0,
  activity_score DECIMAL DEFAULT 0
);
```

---

## 🔍 实际例子

### 例子：创建到显示的完整流程

#### Step 1: 管理员创建市场
```typescript
// 前端提交表单
fetch('/api/admin/markets/create', {
  method: 'POST',
  body: JSON.stringify({
    title: "特斯拉测试",
    description: "测试市场",
    mainCategory: "automotive"
  })
})

// API 处理
db.query(`INSERT INTO markets (title, ...) VALUES (...)`)

// 数据库现在有:
{
  id: 1,
  title: "特斯拉测试",
  blockchain_status: "not_created", ← 重点！
  condition_id: null                ← 重点！
}
```

#### Step 2: 用户浏览市场
```typescript
// 前端请求
const res = await fetch('/api/markets/1');
const market = await res.json();

// 返回的数据（从数据库）:
{
  id: 1,
  title: "特斯拉测试",
  blockchain_status: "not_created", ← 前端知道未激活
  condition_id: null
}

// 前端显示:
<MarketCard market={market}>
  {market.blockchain_status === 'not_created' && (
    <div>市场尚未激活</div>
    <InterestedButton />
    <TradeButton>激活并交易</TradeButton>
  )}
</MarketCard>
```

#### Step 3: 用户标记感兴趣
```typescript
// 前端请求
fetch('/api/markets/1/interested', {
  method: 'POST',
  body: JSON.stringify({ userAddress: "0x..." })
})

// API 更新数据库
db.query(`UPDATE markets SET interested_users = interested_users + 1 WHERE id = 1`)

// 数据库现在:
{
  id: 1,
  interested_users: 1,  ← 更新了
  activity_score: 9     ← 重新计算了
}

// WebSocket 通知所有在线用户
broadcastInterestedUpdate(1, {
  interestedUsers: 1,
  progress: 20%
})

// 所有浏览器实时更新显示 "1/5 人感兴趣"
```

#### Step 4: 达到激活条件
```typescript
// 第 5 个人标记感兴趣
interested_users: 5

// 定时任务扫描（每小时）
const markets = db.query(`
  SELECT * FROM markets
  WHERE blockchain_status = 'not_created'
    AND interested_users >= 5
`)

// 找到市场 ID 1，开始激活
activateMarketOnChain(1)
```

#### Step 5: 链上激活
```typescript
// blockchain-activator.ts

// 1. 从数据库读取市场
const market = await db.query(`SELECT * FROM markets WHERE id = 1`);
// → title: "特斯拉测试"

// 2. 调用智能合约
const tx = await adapter.initialize(
  questionId,
  market.title,        ← 使用数据库的数据
  market.description,  ← 使用数据库的数据
  2,
  USDC_ADDRESS,
  rewardAmount,
  0
);

// 3. 等待交易确认（30 秒）
const receipt = await tx.wait();

// 4. 获取 conditionId
const conditionId = "0xea6d...";

// 5. 更新数据库
await db.query(`
  UPDATE markets
  SET blockchain_status = 'created',
      condition_id = $1,
      activated_at = NOW()
  WHERE id = 1
`, [conditionId]);

// 数据库现在:
{
  id: 1,
  title: "特斯拉测试",
  blockchain_status: "created",    ← 已上链
  condition_id: "0xea6d...",       ← 有链上 ID 了
  activated_at: "2024-10-24..."
}
```

#### Step 6: 激活后显示
```typescript
// 前端重新请求
const market = await fetch('/api/markets/1');

// 返回（从数据库）:
{
  id: 1,
  blockchain_status: "created",    ← 前端知道已激活
  condition_id: "0xea6d..."        ← 有链上 ID
}

// 前端显示:
<MarketCard>
  {market.blockchain_status === 'created' && (
    <div>✅ 市场已激活</div>
    <TradeButton>立即交易</TradeButton>  ← 可以交易了
  )}
</MarketCard>
```

#### Step 7: 用户交易
```typescript
// 现在可以调用链上合约了
const ctf = new ethers.Contract(CTF_ADDRESS, CTF_ABI, signer);

// 使用数据库中的 condition_id
await ctf.splitPosition(
  USDC_ADDRESS,
  PARENT_COLLECTION_ID,
  market.condition_id,  ← 从数据库获取
  partition,
  amount
);
```

---

## 🎯 核心概念

### ✅ 数据库是"主数据源"

```
数据库存储:
  ✅ 市场标题、描述
  ✅ 分类、标签
  ✅ 时间设置
  ✅ 状态管理
  ✅ 活跃度数据
  ✅ 链上 ID（激活后）
  
区块链存储:
  ✅ conditionId（市场唯一标识）
  ✅ questionId
  ✅ Token 合约状态
  ✅ 预言机数据
```

### ✅ 混合读取策略

```typescript
// 读取市场信息 → 数据库（快）
const market = await supabase.from('markets').select('*');

// 读取 Token 余额 → 区块链（慢）
const balance = await ctf.balanceOf(address, tokenId);

// 读取订单簿 → 数据库（快）
const orderBook = await db.query(`SELECT * FROM orders WHERE market_id = 1`);

// 最终结算 → 区块链（安全）
await ctfExchange.fillOrders(...);
```

---

## 📋 完整数据流总结

### 创建阶段
```
后台表单 → API → 数据库 ✅
成本: $0
速度: < 100ms
位置: 100% 链下
```

### 显示阶段
```
前端页面 → API → 数据库 → 返回 JSON ✅
成本: $0
速度: < 100ms
位置: 100% 链下
```

### 激活阶段
```
触发条件 → API → 读数据库 → 调合约 → 更新数据库 ✅
成本: ~$0.10（平台支付）
速度: ~30 秒
位置: 链下读取 → 链上写入 → 链下更新
```

### 交易阶段
```
用户下单 → API → 数据库匹配 → 批量结算 → 区块链 ✅
成本: $0（链下）+ 批量结算（节省 70%）
速度: < 100ms（链下）
位置: 大部分链下，最终链上确认
```

---

## 💡 为什么这样设计？

### 优势对比

**纯区块链方案**：
```
创建市场 → 立即上链
显示市场 → 从链上读取（慢）
订单 → 每笔都上链（贵）

成本: 高 ❌
速度: 慢 ❌
```

**我们的方案（数据库 + 区块链）**：
```
创建市场 → 数据库（免费）
显示市场 → 数据库（快速）
订单 → 数据库匹配（快速）+ 链上结算（安全）

成本: 节省 80-90% ✅
速度: 10-100 倍提升 ✅
```

---

## ✅ 总结

**你的理解完全正确！**

1. ✅ 创建市场 → **保存到数据库**
2. ✅ 显示市场 → **从数据库读取（链下）**
3. ✅ 激活市场 → **上链 + 更新数据库**
4. ✅ 交易订单 → **数据库匹配 + 批量链上结算**

**数据库是核心**，区块链只在必要时使用（激活、结算）。

这就是 Polymarket 的核心思想：**链下 + 链上混合架构**！

---

**创建时间**: 2025-10-24  
**说明**: 完整数据流


